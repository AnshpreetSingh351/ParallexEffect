<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GLB Gyro Rotate</title>
<style>
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
    background: #0b0b0b;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<!-- Babylon.js -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

// Camera (fixed)
const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 0, -3), scene);
camera.setTarget(BABYLON.Vector3.Zero());

// Light
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
light.intensity = 1.2;

let rootMesh = null;

// Load GLB
BABYLON.SceneLoader.ImportMesh(
  "",
  "",
  "model.glb",
  scene,
  function (meshes) {
    // Create a parent root to rotate
    rootMesh = new BABYLON.TransformNode("root", scene);

    meshes.forEach(m => {
      m.parent = rootMesh;
    });

    // Center model
    const bounds = rootMesh.getHierarchyBoundingVectors();
    const center = bounds.min.add(bounds.max).scale(0.5);
    rootMesh.position.subtractInPlace(center);
  }
);

// Gyro values
let targetX = 0, targetY = 0;
let currentX = 0, currentY = 0;

// Handle device orientation
function handleOrientation(e) {
  const gamma = e.gamma || 0; // left-right
  const beta = e.beta || 0;   // front-back

  // Make upright phone = 0
  const uprightBeta = beta - 90;

  targetX = gamma * 0.01;        // Y rotation
  targetY = uprightBeta * 0.01;  // X rotation
}

// iOS permission
if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
  document.body.addEventListener("click", () => {
    DeviceOrientationEvent.requestPermission().then(() => {
      window.addEventListener("deviceorientation", handleOrientation);
    });
  }, { once: true });
} else {
  window.addEventListener("deviceorientation", handleOrientation);
}

// Render loop
engine.runRenderLoop(() => {
  if (rootMesh) {
    // Smooth damping
    currentX += (targetX - currentX) * 0.08;
    currentY += (targetY - currentY) * 0.08;

    rootMesh.rotation.y = currentX;
    rootMesh.rotation.x = currentY;
  }

  scene.render();
});

window.addEventListener("resize", () => {
  engine.resize();
});
</script>

</body>
</html>
